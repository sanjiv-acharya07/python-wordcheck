# python-wordcheck
## Part 1
Part one utilizes four different hash functions to form a table and store a word. These functions are ASCII Sum, Jenkins Hash, Division Hash, and FNV1A Hash. For the ASCII and Jenkins functions, the input will contain just the hash function, the string, and the table size. For Division Hash and FNV1A Hash, the input will contain everything stated previously but also a seed. The order will be this separated by a comma in the file: hash function, table size, seed (if needed), string. The output will be the hash value mod table size, or in other words the spot in the hash table where the word is stored.

## Part 2
Part two utilizes the bloom filter created in the bloom_filter.py class. This part recieves an input of table size and a list of strings and uses the bloom filter to store them. The hash functions of the bloom filter are the 22 variations of the hash functions in part one. The bloom filter runs each hash function for each word and keeps track of the number of bits changed in the bloom filter (this is also the number of hash functions had a free spot to store the string). Once the program is finished running, the output will contain a list of the number of hash functions that store each word. The input of this part will be the same as the file in part2/inputs, but feel free to change the words and table size.

## Part 3
Part three imports nltk.corpus packages to see if words within the input file are contained in the corpus. To do this a bloom filter with table size 18000000 and the 22 hash functions from part one is created. Each word in the corpus is added to the bloom filter after being lowercased and the punctuation removed. Once process has finished, the input file of a paragraph of text is read. Every word is checked to see if it is inside the bloom filter, and if it is not then added to a list. The output of this program is a list of words in the paragraph that are not in the corpus.

## Part 4
Part 4 imports the Levenshtein and nltk.corpus packages to create a spell check. To do this, a binary tree was created to be able to utilize the heapq package and move nodes along the tree. The input of this part is a misspelled word and a number, and the program will use the Levenshtein distance between the input word and the words in the corpus to create a binary tree. The tree will then return the amount of words that the input number states. These words will be the closest corrections to the misspelled word based on Levenshtein distance. 
